<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[第三章 按位运算符(三)]]></title>
    <url>%2F2020%2F05%2F20%2F%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[按位运算符 按位运算符有6个如下表： 运算符 说明 &amp; 按位与运算符 ｜ 按位或运算符 ^ 按位异或(EOR)运算符 ~ 按位非运算符，也成为1的补位运算符 &lt;&lt; 按位左运算符 &gt;&gt; 按位右运算符 这些运算符只能用与整数类型。~运算符是一元运算符，只处理一个操作数，其他的都是二元运算符 按位与运算符假设如果 x = 13，且 y = 6，现在以二进制格式表示，它们如下所示： A = 0011 1100 B = 0000 1101 运算符 描述 实例 &amp; 按位与操作，按二进制位进行”与”运算。运算规则：0&amp;0=0; 0&amp;1=0; 1&amp;0=0; 1&amp;1=1; (A &amp; B) 将得到 12，即为 00001100 按位或运算符假设如果 x = 13，且 y = 6，现在以二进制格式表示，它们如下所示： A = 0011 1100 B = 0000 1101 运算符 描述 实例 ｜ 按位或运算符，按二进制位进行”或”运算。运算规则：0｜0=0; 0｜1=1; 1｜0=1; 1｜1=1; (A ｜ B) 将得到 61，即为 00111101 按位异或运算符假设如果 x = 13，且 y = 6，现在以二进制格式表示，它们如下所示： A = 0011 1100 B = 0000 1101 运算符 描述 实例 ^ 异或运算符，按二进制位进行”异或”运算。运算规则：0^0=0; 0^1=1; 1^0=1; 1^1=0; (A ^ B) 将得到 61，即为 00110001 按位非运算符假设如果 x = 13，且 y = 6，现在以二进制格式表示，它们如下所示： A = 0011 1100 B = 0000 1101 运算符 描述 实例 ~ 取反运算符，按二进制位进行”取反”运算。运算规则：~1=0; ~0=1; (~A ) 将得到 -61，即为 11000011，一个有符号二进制数的补码形式。 按位左移运算符假设如果 x = 13，且 y = 6，现在以二进制格式表示，它们如下所示： A = 0011 1100 B = 0000 1101 运算符 描述 实例 &lt;&lt; 二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。 A &lt;&lt; 2 将得到 240，即为 11110000 按位右移运算符 运算符 描述 实例 &gt;&gt; 二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 A &gt;&gt; 2 将得到 15，即为 00001111 按位运算符的op=用法 所有的二元按位运算符都可以在op=形式的赋值语句中使用，用~运算符例外，他是一元运算符例如： 1hs op=rhs; 等价于 1hs=1hs op (rhs); 例如： value &lt;&lt;=4; 其作用是将整数变量value的内容向左移动四位。等效于： value = value &lt;&lt; 4; 二元运算符可以这样使用。例如： value &amp;=0xFF; 其中value是一个整数变量，就等价于： value = value&amp; 0xFF; 其作用是使最右边的8位保持不变，其他的位置都设为0]]></content>
      <categories>
        <category>C语言学习</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无法创建映射网络驱动器解决方法]]></title>
    <url>%2F2020%2F05%2F17%2F%E6%97%A0%E6%B3%95%E5%88%9B%E5%BB%BA%E6%98%A0%E5%B0%84%E7%BD%91%E7%BB%9C%E9%A9%B1%E5%8A%A8%E5%99%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言今天搭建好网盘开启webdav服务后，在自己电脑上添加一个网络硬盘时，磁盘映射的时候，提示“无法创建映射网络驱动器：连到系统上的设备没有发挥作用” 解决方法 需要修改注册表 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\WebClient\Parameters，把BasicAuthLevel 值改成2 使用管理员身份重启webclient服务：net stop webclient //停止 net start webclient //启动]]></content>
      <categories>
        <category>遇到的问题和解决方法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第三章 多项选择问题（二）]]></title>
    <url>%2F2020%2F03%2F28%2F%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%A4%9A%E9%A1%B9%E9%80%89%E6%8B%A9%E9%97%AE%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 在编程时，常常会遇到多项选择问题，在c语言中有两种方式处理多项选择问题，一种是采用else-if形式的if语句，这是处理多项选择最常见的方式，另一种是switch语句，它限制了某个选项的方式但是也提供了一种非常简洁且便于理解的解决方案 else-if 语句#include &lt;stdio.h&gt; int main(void) { int a; scanf(&quot;%d&quot;,&amp;a); if(a==1) printf(&quot;1&quot;); else if(a==2) printf(&quot;2&quot;); else if(a==3) printf(&quot;3&quot;); else if(a==4) printf(&quot;4&quot;); else printf(&quot;5&quot;); } 每个if表达式均可任意，只要其结果是true或false即可，如果第一个if表达式(a==1)时false,就执行下一个if,如果第二个if表达式(a==2)时false,就执行下一个if,直到找到一个结果为true的表达式为止，如果if条件都为false，就执行最后一个else switch 语句switch语句允许根据一个整数表达式的结果，从一组动作中选择一个动作，假定有一个彩票店，数字35可赢得一等奖，122可赢得二等奖，78可赢得三等奖，代码如下 #include &lt;stdio.h&gt; int main(void) { int zjh; //变量中奖号 scanf(&quot;%lf&quot;,&amp;zjh); //输入中奖号 switch(zjh) //zjh不能为浮点数 //括号中表达式的值zjh,它确定执行那些语句，zjh的值与case指定的语句匹配，就执行case后面的语句 { case 35: printf(&quot;你获得了一等奖&quot;); break; //break的作用是跳过大括号中的其他语句 case 122: printf(&quot;你获得了二等奖&quot;); break; case 78: printf(&quot;你获得了三等奖&quot;); break; default: //如果都不对应任何case的值，就执行default后面的语句 printf(&quot;抱歉！没有中奖&quot;); break; } } switch语句流程图 switch的一般形式如下 switch（integer_expression) { case constant_expression_1: statements_1; break; ···· case constant_expression_n: statements_n; break; default: statements; break; } 还可以使用char值的表达式作为switch的控制表达式：如下代码区分元音字母和辅音字母 #include &lt;stdio.h&gt; int main(void) { char ch; printf(&quot;请输入字母&quot;); scanf(&quot;%c&quot;,&amp;ch); switch(ch) { case &#39;a&#39;:case&#39;e&#39;:case&#39;i&#39;:case&#39;o&#39;:case&#39;u&#39;: printf(&quot;你输入的是元音字母&quot;); break; case&#39;b&#39;:case&#39;c&#39;:case&#39;d&#39;:case&#39;f&#39;:case&#39;j&#39;:case&#39;k&#39;:case &#39;l&#39;: case&#39;m&#39;:case&#39;n&#39;:case&#39;p&#39;:case&#39;q&#39;:case&#39;r&#39;:case &#39;s&#39;:case&#39;t&#39;: case&#39;v&#39;:case&#39;w&#39;:case&#39;x&#39;:case&#39;y&#39;:case&#39;z&#39;: printf(&quot;你输入的是辅音字母&quot;); break; default: printf(&quot;输入有误&quot;); break; } } 使用&lt;ctype.h&gt;头文件声明isalpha()函数，会大大缩减代码。如果作为参数传入的字符是字母，isalpha()函数就会返回一个非零整数(true),否则返回(false). #include &lt;stdio.h&gt; #include &lt;ctype.h&gt; int main() { char ch; printf(&quot;请输入字母&quot;); scanf(&quot;%c&quot;,&amp;ch); if(!isalpha(ch)) //如果不是大小写字母ch的值就是true,就执行printf， printf(&quot;输入有误&quot;); else { switch(tolower(ch)) //(tolower(ch)将ch的值转化为小写 { case&#39;a&#39;:case&#39;e&#39;:case&#39;i&#39;:case&#39;o&#39;:case&#39;u&#39;: printf(&quot;你输入的是元音字母&quot;); break; default: printf(&quot;你输入的是辅音字母&quot;); break; } } } &lt; ctype.h &gt; 头文件好可以声明其他函数： 函数 测试内容 islower() 小写字母 isupper() 大写字母 isalnum() 大写或小写字母，或十进制数字 iscntrl() 控制字符 isprint() 可打印字符包括括号 isgraph() 可打印字符不包括括号 isdigit() 十进制数字0~9 isxdigit() 十六进制数字（0~9，A~F，a~f) isblank() 标准空白字符（空格，\t) isspac() 空位字符(空格，\n,\t,\v,\r,\f) ispunct() isspace()和isalnum()返回false的可打印字符 isalpha() 大写或小写字母 tolower() 转换为小写形式 toupper() 转换为大写形式 goto语句 goto语句是一个比较生硬的指令，它可以无条件的改变程序的顺序，goto语句会直接跳转到指定的位置，无需检查任何值或者要求用户考虑这是否是他希望执行的操作 goto 语句的语法： goto label; ··· ··· label: statement; 在这里，label 可以是任何除 C 关键字以外的纯文本，它可以设置在 C 程序中 goto 语句的前面或者后面。 #include &lt;stdio.h&gt; int main() { printf(&quot;1&quot;); printf(&quot;2&quot;); goto there; //跳转到下一个 there; printf(&quot;3&quot;); printf(&quot;4&quot;); there: //跳到这里开始执行 printf(&quot;5&quot;); printf(&quot;6&quot;); } 输出结果 1256 goto语句执行流程图]]></content>
      <categories>
        <category>C语言学习</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三章 判断过程（一）]]></title>
    <url>%2F2020%2F03%2F16%2F%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[C语言中的判断过程 在我们现实生活中，我们总是做出判断例如：如果外面下雨，我就坐车去学校。如果外面不下雨，我就骑自行车去学校 算术比较 c中比较两个值有6个关系运算符，如表： 运算符 比较 &lt; 左操作数小于右操作数 &lt;= 左操作数小于等于右操作数 == 左操作数等于右操作数 != 左操作数不等于右操作数 &gt; 左操作数大于右操作数 &gt;= 左操作数大于等于右操作数 基本的if语句 有了比较关系运算符后，就需要用一个语句来做判断最简单的语句就是if语句。例如比较自己的体重和他人的体重，代码如下： #include &lt;stdio.h&gt; int main(void) { int my_weight=170； //定义我的身高为170 int you_weight=175；//定义你的身高为175 if(you_weight&gt;my_weight) //如果你的身高大于我的身高 printf(&quot;你比我高&quot;); //printf就会执行 你比我高 if(you_weight&lt;my_weight) //如果你的身高小于我的身高 printf(&quot;我比你高&quot;); //printf就会执行我比你高 if(you_weight==my_weight) //如果你的身高小于我的身 printf(&quot;我们一样高&quot;); //printf就会执行你和我意昂高 } 结果为：你比我高 这三个if语句，比较表达式位于if关键字后面的括号里，如果比较结果为true,就执行if后面的语句，如果表达式为false,就跳过if后面的语句 if语句的一般形式或语法如下： if(expression) statement1； Next_statement； 在第一行的末尾没有分号，是因为if关键字和其后的一行组合在一起如下： if(expression) statement1； Next_statement； 但为了简洁，一般把statement1放在新的一行 if 语句的执行过程如图 把一个数值转换为bool类型时，会得到一个布尔结果 if语句的控制表达式要生成一个布尔结果 所以编译器要把if表达式的数值转换为bool类型。 有时在程序中会使用它测试计算式的非零结果 如下面的语句：if(count) printf(&quot;count的值不为零&quot;)； 只有count非零，printf才会执行，如果count的值为零，表示if表达式为false，任何非零的count值都会使表达式的结果为true,如下代码： #include &lt;stdio.h&gt; int main(void) { int a； printf(&quot;请输入一个数字&quot;)； scanf(&quot;%d&quot;,&amp;a)； if(a) printf(&quot;a的值不为零&quot;)； } 如果输入2 结果为：a的值不为零 如果输入0 结果为： 当a的值为零，表示if表达式为false，printf不会执行 扩展if语句：if-else可以扩展if语句提供更多的灵活性例如： 如果今天的雨比昨天大 我就带上雨伞 否则 我就穿上皮夹克 然后去学校 这就是if-else提供的判断方式.if-else语句的语法如下： if(experssion) statement1； else statement2； Next_statement； 如果expression的值是true,就执行statement1,之后执行Next_statement。 如果expression的值是false,就执行statement2,之后执行Next_statement。 执行过程如图: 在if语句中使用代码块 可以把几个语句放在一个{}中，在if表达式为true时，提供多个执行的语句例如： 如果天气晴朗 我就去公园，吃野餐，然后回家 否则 我就留在家中，看足球赛，喝啤酒 if语句的语法如下: if(expression) { statementA1; statementA2; } else { statementB1; statementB2; } Next_statement; 如果expression等于true,就执行if后面括号中所有的语句 如果expression等于false,就执行else后面括号中所有的语句 在两种情况下程序都执行 Next_statement 嵌套的if语句 if语句也可以包含if语句。例如 如果天气很好 我就到院子里去 如果天气很冷 我就坐在太阳下 否则 我就坐下树荫下 否则 我就呆在屋内 然后喝一些柠檬水 if语句的语法如下： if(expression1) { statementA； if(expression2) statementB； else statementC； } else statementD； statementE； 第二个if语句只有在第一个if语句为true时才执行，其逻辑如图 逻辑与算符 逻辑与运算符&amp;&amp; （逻辑与)运算符&amp;&amp;是一个二元运算符，因为它合并两个逻辑表达式，即两个值为true或false的表达式，例如： if(age&gt;12 &amp;&amp; age&lt;20) printf(&quot;你正式成为青少年&quot;)； &amp;&amp; (逻辑与) 当逻辑与左边为false(假)，则不再进行逻辑与右边的判断，结果为false(假) 当逻辑与左边为true(真)则进行右边判断，右边为false(假)，结果为false(假) 当逻辑与左边为true(真)则进行右边判断，右边也为true(真)，则结果为true(真) 逻辑或运算符|| (逻辑或)运算符||用于两个或多个条件为true的情行。如果运算符||的一个或两个操作数是true,其结果就是true.只有两个操作数都是false,结果才是false.下面是使用这个运算符的例子: #include &lt;stdio.h&gt; int main() { int a=6; if(a&gt;7 || a&gt;9 || a==7 || a==5 || a==6) printf(&quot;printf语句执行了&quot;); } 结果为：printf语句执行了 ||(逻辑或) 当逻辑或左边为false(假)，继续逻辑或右边的判断，如果也为false(假)，结果为false(假) 当逻辑或左边为false(假)，继续逻辑或右边的判断，如果为true(真)，结果为true(真) 当逻辑或左边为true(真)，则不再进行逻辑或右边的判断，结果为true(真) 逻辑非运算符！ 逻辑非运算符用 “!”表示，他是一元运算符；因为他只有一个操作数。逻辑非运算符转逻辑表达式的值，使用true和false，假设有两个变量a和b，其值分别是5和2，则表达式a&gt;b是true，如果使用逻辑非运算符，表达式!(a&gt;b)就是false，尽量避免使用这个运算符，它会使代码难以理解。 条件运算符 条件运算符根据一个逻辑表达式等于true和false。执行两个表达式中的一个。有时也称为三元运算符，因为他是需要3个操作数的运算符例如： 条件？表达式1:表达式2 x=y&gt;7?25:50； 如果y&gt;7,x就设置为25，否则x就设置为50，这是生成这一结果的一种快捷方式： if(y&gt;7) x=25; else x=50; 如下代码 #include &lt;stdio.h&gt; int main(void) { int a,b,max； printf(&quot;请输入两个数字&quot;)； scanf(&quot;%d&quot;，&amp;max)； max=a&gt;b?a:b；//当a&gt;b为true,max的值为a。当为false,max的值为b. printf(&quot;max=%d&quot;,max)； return 0； } 运算符的优先级 优先级 运算符 结合律 1 后缀运算符：[] () · -&gt; ++ –(类型名称){列表} 从左到右 2 一元运算符：++ – ! ~ + - * &amp; sizeof_Alignof 从右到左 3 类型转换运算符：(类型名称) 从右到左 4 乘除法运算符：* / % 从左到右 5 加减法运算符：+ - 从左到右 6 移位运算符：&lt;&lt; &gt;&gt; 从左到右 7 关系运算符：&lt;&lt;= &gt;&gt;= 从左到右 8 相等运算符：== != 从左到右 9 位运算符 AND：&amp; 从左到右 10 位运算符 XOR：^ 从左到右 11 位运算符 OR： 从左到右 12 逻辑运算符 AND：&amp;&amp; 从左到右 13 逻辑运算符 OR： 从左到右 14 条件运算符：?: 从右到左 15 赋值运算符：= += -= * = /= %= &amp;= ^= ❘= 从右到左 16 逗号运算符：， 从左到右]]></content>
      <categories>
        <category>C语言学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[创建第一个C程序]]></title>
    <url>%2F2019%2F12%2F26%2F%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAC%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[C程序示例C 程序主要包括以下部分： 预处理器指令 函数 变量 语句 &amp; 表达式 注释 #include &lt;stdio.h&gt; int main(void) { printf(&quot;Hello world ! \n&quot;)； return 0； } 编译执行后会输出 Hello World! 接下来我们讲解一下上面这段程序： 程序的第一行 #include &lt;stdio.h&gt; 严格来说它不是可执行程序的一部分，但它很重要，程序没有它是不执行的。符号#表示这是一个预处理命令，告诉编译器在执行代码之前先做一些操作。预处理指令相当多，一般放在源文件的开头。头文件是包含函数声明定义的文件；你平时写C语言时，用到的printf（） 和scanf()都是系统定义好的，而这些函数的定义就包含在stdio.h这个文件中！ 第二行int main(void) 注意这行代码的末尾没有分号， int表明main函数要返回一个整数作为返回值, 执行完main()函数后的整数值表示返回给操作系统的一个代码，他表示程序的状态。 printf 产生格式化输出的函数（定义在 stdio.h 中），其向终端显示器、控制台等）输出字符。 return 0； 这个return语句结束main()函数执行，把0返回给操作系统 C基本语法C 程序由各种令牌组成，令牌可以是关键字、标识符、常量、字符串值，或者是一个符号。例如，下面的 C 语句包括五个令牌： printf(“Hello, World! \n”)； 这五个令牌分别是： printf ( &quot;Hello, World! \n&quot; ) ； 分号 ；在 C 程序中，分号是语句结束符。也就是说，每个语句必须以分号结束，必须用英文的符号。它表明一个逻辑实体的结束。例如，下面是两个不同的语句： printf(&quot;Hello, World! \n&quot;)； return 0； 注释C 语言有两种注释方式：以 // 开始的单行注释，这种注释可以单独占一行。 //单行注释 / / 这种格式的注释可以单行或多行。 / 单行注释 / / 多行注释 多行注释 多行注释 / 关键字 在C语言中，关键字是有特殊意义的字，所以在程序中不能将关键字用于其它目的。关键字也称保留字，在前面例子中，int void return都是关键字 关键字 说明 auto 声明自动变量 break 跳出当前循环 case 开关语句分支 char 声明字符型变量或函数返回值类型 const 声明只读变量 continue 结束当前循环，开始下一轮循环 default 开关语句中的”其它”分支 do 循环语句的循环体 double 声明双精度浮点型变量或函数返回值类型 else 条件语句否定分支（与 if 连用） enum 声明枚举类型 extern 声明变量或函数是在其它文件或本文件的其他位置定义 float 声明浮点型变量或函数返回值类型 for 一种循环语句 goto 无条件跳转语句 if 条件语句 int 声明整型变量或函数 long 声明长整型变量或函数返回值类型 register 声明寄存器变量 return 子程序返回语句（可以带参数，也可不带参数） short 声明短整型变量或函数 signed 声明有符号类型变量或函数 sizeof 计算数据类型或变量长度（即所占字节数） static 声明静态变量 struct 声明结构体类型 switch 用于开关语句 typedef 用以给数据类型取别名 unsigned 声明无符号类型变量或函数 union 声明共用体类型 void 声明函数无返回值或无参数，声明无类型指针 volatile 说明变量在程序执行中可被隐含地改变 while 循环语句的循环条件 函数体main()函数的一般结构如图 函数体是在函数名称后面位于起始及结束的两大括号之间的代码，它包含了函数功能的所有语句。]]></content>
      <categories>
        <category>C语言学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[校园网的天翼网关获取超级用户]]></title>
    <url>%2F2019%2F10%2F26%2F%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%9A%84%E5%A4%A9%E7%BF%BC%E7%BD%91%E5%85%B3%E8%8E%B7%E5%8F%96%E8%B6%85%E7%BA%A7%E7%94%A8%E6%88%B7%2F</url>
    <content type="text"><![CDATA[前言刚开学不久，上一届学生应该是校园网到期了，把电信的光猫路由器扔了，正好上楼梯在垃圾桶旁，我看到就捡走了，拿回去还可以做路由器有，拿回去才发现路由器的后台功能也就能改一个wifi的名字而已，一些路由器的基本功能都没有，后来我打算直接用ttl线刷固件，在网上搜他的型号时发现他还有一个超级用户，这个用户是为了安装宽带时用的，根据自己的经验和一些线索，找到了超级用户的用户名和密码，从而达到了自己想用的功能 破解步骤 根据设备型号HG221GS，上网查找资料，参考网上的方法，输入：http://192.168.1.1:8080/cgi-bin/baseinfoSet.cgi 打开后找到关键信息 &quot;baseinfoSet_TELECOMACCOUNT&quot;:&quot;telecomadmin&quot;, &quot;baseinfoSet_TELECOMPASSWORD&quot;:&quot;114&amp;73&amp;55&amp;110&amp;69&amp;37&amp;53&amp;113&amp;&quot;, &quot;baseinfoSet_USERACCOUNT&quot;:&quot;useradmin&quot;, &quot;baseinfoSet_USERPASSWORD&quot;:&quot;106&amp;110&amp;117&amp;122&amp;50&amp;&quot;, 通过观察9CD2H与57&amp;71&amp;72&amp;50&amp;76&amp;的对应关系（ASCII码），进行解码，如下所示： code=&#39;114&amp;73&amp;55&amp;110&amp;69&amp;37&amp;53&amp;113&amp;&#39;[:-1] # &quot;baseinfoSet_TELECOMPASSWORD&quot;:&quot;114&amp;73&amp;55&amp;110&amp;69&amp;37&amp;53&amp;113&amp;&quot; list=map(int,code.split(&#39;&amp;&#39;)) result=[] for i in list: if i &gt; 57: i-=4 result.append(chr(i)) print (&#39;&#39;.join(result)) # output password:nE7jA%5m 找个python的线上编辑器，运行上述代码，得到默认密码nE7jA%5m 输入超级管理员账号：telecomadmin 密码： nE7jA%5m 登陆成功]]></content>
      <categories>
        <category>搞机笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[中兴机顶盒B860AV1.1破解]]></title>
    <url>%2F2019%2F08%2F24%2F%E4%B8%AD%E5%85%B4%E6%9C%BA%E9%A1%B6%E7%9B%92B860AV1-1%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言这个机顶盒是联通运营商赠的，所以里面有很多限制比如必须使用这个机器的宽带账号，要不然连不上网，30秒弹出一次认证界面，不可以安装第三方软件，一开始我把软件放到了SD卡准备插卡安装时，提示我禁止安装第三方软件。后来我就去百度了一下，发现有破解教程 破解教程找到成功的有两个破解教程 通过adb破解工具进行破解 通过usb转tttl线插到机顶盒板子上的开发商的接口上 我先试了第一种方法，并没有成功，可能是开发商修补了漏洞 只能使用第二种方法了，在淘宝上买了USBTOTTL(8块大洋) 准备 购买TTL线后，向店家要一个相应的驱动软件 U盘一个，用来储存当贝市场和当贝桌面，将这两个软件下载拷贝至U盘中，并将文件名改为“dangbei1”和“dangbei2”当贝市场下载地址：http://app.znds.com/update/dangbeimarket.apk 当贝桌面下载地址：http://www.dangbei.com/zhuomian/ 教程 首先将机顶盒机器后盖打开，需要用螺丝刀等工具撬开后拧下螺丝取出主板; 准备开始用USB转TTL线接线， 将TTL线的GND接2号口，RX线接5号口，TX线接6号口注意：如果稍后不能跑码的话，就将5、6接口上的线调换位置，如果还是无法跑码，就将接线顺序整体调换，意思就是反转过来重新接！！ 将USB接口插到电脑上后，安装店家给你的驱动软件，接着需要调试一些参数，右键我的电脑——属性——设备管理器——端口——COM”X”（X就是最后位数字）——属性——端口设置——改为“115200”——确定； 打开之前下载好的“PUTTY”按图中的顺序设置即可，COM后面的数字按照自己电脑的端口号输入即可，在这里记得把U盘插到机顶盒的USB接口上； 接着将盒子的盒子电源接通，通电开始跑码，如果没有跑码，注意：就将5、6接口上的线调换位置，如果还是无法跑码，就将接线顺序整体调换，意思就是整体反转过来重新接，线的顺序也要按照上述重新排序；** 成功跑码后开始输入代码，直接复制下述代码到“PUTTY”中，每输入一行按一下回车；start adbd 注释：打开adb** 查看U盘路径df 红线标出的就是U盘路径注：红线标出的U盘路径可能与你输入df后的不相符，要以当前设备的路径为准，至于如何查看，可以从U盘大小看出来，比如上图中sda1后面的数字，U盘是3.8G。 进入u盘 ,复制当贝市场和当贝桌面到盒子应用中cp dangbei1.apk /data/app cp dangbei2.apk /data/app 启动当贝桌面am start com.dangbei.tvlauncher ok，至此当贝市场和当贝桌面就安装成功了]]></content>
      <categories>
        <category>搞机笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[基于Docker的蜜罐平台搭建]]></title>
    <url>%2F2019%2F07%2F27%2F%E5%BC%80%E6%BA%90%E8%9C%9C%E7%BD%90%E6%90%AD%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[蜜罐技术:蜜罐本质上是一种对攻击者进行欺骗技术，通过布置一些作为诱饵的主机、网络服务或信息，诱使攻击方对它们实施攻击，从而可以对攻击行为进行捕获和分析，蜜罐一般是在隔离环境，攻击者入侵后是在系统之上的系统中，攻击者做的任何事情都记录在系统中，以供分析 T-pot19.03T-pot 19.03运行在debian(Sid)上，基于docker, docker-compose并且包括以下蜜罐的docker镜像:adbhoney，ciscoasa，conpot，cowrie，dionaea，elasticpot，glastopf，glutton、heralding，honeypy，honeytrap，mailoney，medpot，rdpy，snare，tanner据介绍为了更接近滚对发布模型设计，此版本从ubuntu迁至debian 部署完成后 官方介绍官方介绍: https://dtag-dev-sec.github.io/mediator/feature/2016/10/31/t-pot-16.10.html 官方github： https://github.com/dtag-dev-sec/tpotce 一、安装 安装要求 6-8GRAM128G磁盘空间 安装模式 标准安装、传感器安装、 工业安装、 收集器安装 、 下一代安装 详细信息见官方说明 https://github.com/dtag-dev-sec/tpotce#postinstallauto 提供三种安装方式： 裸设备安装 1、获取ISO的方式: ISO方式： https://github.com/dtag-dev-sec/tpotce/releases/download/19.03/tpot.iso 基于现有系统安装我第一次用的官方的iso安装,安装了两天都没安装好，速度太慢了，然后我直接用的纯净最小安装包debian9.8安装的，下面是我基于现有系统安装的安装步骤 安装要求 6-8GRAM 128G磁盘空间 连接网络 更换apt源cp /etc/apt/sources.list /etc/apt/sources.list_bak_$(date +%F) #T-pot使用的是Sid版本所以我添加的源也是Sid版的(注释的是官方提供的其中一个国外源站): echo &quot;deb http://mirrors.163.com/debian/ sid main non-free contrib deb-src http://mirrors.163.com/debian/ sid main non-free contrib deb https://mirrors.tuna.tsinghua.edu.cn/debian/ sid main non-free contrib deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ sid main non-free contrib deb http://mirrors.ustc.edu.cn/debian/ sid main non-free contrib deb-src http://mirrors.ustc.edu.cn/debian/ sid main non-free contrib #deb http://ftp.sg.debian.org/debian/ sid main non-free contrib #deb-src http://ftp.sg.debian.org/debian/ sid main non-free contrib deb http://ftp.hk.debian.org/debian/ sid main non-free contrib deb-src http://ftp.hk.debian.org/debian/ sid main non-free contrib &quot; &gt; /etc/apt/sources.list apt-get update apt-get install curl git 安装apt-fastapt-fast 加速包下载速度，通过aria2的多线程在多个镜像源中进行下载同一个文件,此步骤可忽略,install.sh会自动安装 apt-get install aria2 -y git clone https://github.com/ilikenwf/apt-fast.git cd apt-fast/ cp apt-fast /usr/bin/ cp apt-fast /usr/local/sbin/ chmod +x /usr/bin/apt-fast chmod +x /usr/local/sbin/ cp apt-fast.conf /etc apt-fast update sed -i &quot;/^ *MIRRORS/d&quot; /etc/apt-fast.conf echo &quot;MIRRORS=( &#39;http://mirrors.163.com/debian/,https://mirrors.tuna.tsinghua.edu.cn/debian/,http://mirrors.ustc.edu.cn/debian/&#39; ) &quot; &gt;&gt; /etc/apt-fast.conf #后面看了下T-pot install脚本发现脚本内有下载apt-fast(所以可以不用自己下载apt-fast)😓 #此框命令可选执行，建议执行一遍用不了多久 配置npm源apt-fast install npm npm config set registry http://registry.npm.taobao.org #将npm源换成国内源 克隆Tpot#这里指定克隆库到/opt/tpot,因为此版的install.sh中会到这个目录下读配置文件，不存在的话，会自动再从github clone一份 git clone https://github.com/dtag-dev-sec/tpotce /opt/tpot 更改脚本#发现脚本会将镜像源替换成官方源，需要将脚本中的替换命令删除，以下是19.03版本的删除命令: sed -i &#39;/^ *tee \/etc/d&#39; install.sh sed -i &#39;/^ *deb/d&#39; install.sh sed -i &quot;$(cat -n install.sh | grep &quot;EOF$&quot; | awk &#39;{print $1}&#39; | sed -n &quot;1p&quot;)d&quot; install.sh #以上三条命令不建议在非19.03版本运行，可能install脚本内容更改。 sed -i &quot;/^ *git clone https:\/\/github/d&quot; install.sh #此条删除install.sh中克隆库到/opt/tpot前面已经克隆到这个目录所以删除 #默认拉docker镜像的是国外的网站，总有几个镜像拉不动，配置加速会快很多 cd /opt/tpot/iso/installer AA=$(cat -n install.sh | grep &quot;myTPOTCOMPOSE&quot; | grep &quot;for name in&quot; | awk &#39;{ print $1 }&#39;) sed -i &quot;${AA}i curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io&quot; install.sh sed -i &quot;${AA}a systemctl restart docker&quot; install.sh 安装cd tpot/iso/installer/ ./install.sh --type=user #如果中途退出执行install.sh，可能会报版本不支持错误，需要删除检测版本验证 sed -i &quot;s/if \[ \&quot;\$myLSB\&quot; \!=.*/if \[ 1 \!= 1\]\;/&quot; install.sh #github克隆速度慢的话可以尝试更改hosts文件 echo &quot;13.229.188.59 github.com www.github.com 185.199.111.153 assets-cdn.github.com www.assets-cdn.github.com 151.101.228.249 global.ssl.fastly.net www.global.ssl.fastly.net&quot; &gt;&gt; /etc/hosts 检查安装 检查Tpot服务 systemctl status tpot 检查容器 cd /opt/tpot/bin ./dps.sh #如果没有启动参考下面使用中的启动命令 #如果部分没有成功下载，可以手动下载下面的下载缺失容器 下载缺失容器 cd /opt/tpot/etc/compose for i in `cat ./standard.yml | grep image | cut -d &#39;&quot;&#39; -f2 | uniq` do docker pull $i done 启动容器 cd /opt/tpot/etc/compose docker-compose -f ./standard.yml #如果安装别的模式yml用相应版本的 #如果部分没有成功下载，可以手动下载 使用 启动Tpot服务 systemctl start tpot 停止Tpot服务 systemctl stop tpot 选择关闭数据提交默认情况，捕获的数据将提交给社区后端，并在 Sicherheitstacho 网站进行展现，可根据个人喜好关闭 停止T-Pot服务 systemctl stop tpo 删除Ewsposter服务 vi /opt/tpot/etc/tpot.yml 删除以下行，保存并退出 # Ewsposter service ewsposter: container_name: ewsposter restart: always networks: - ewsposter_local image: &quot;dtagdevsec/ewsposter:1903&quot; volumes: - /data:/data - /data/ews/conf/ews.ip:/opt/ewsposter/ews.ip 启动T-Pot服务 systemctl start tpot 选择加入HPFEEDS分享数据现在可以与第三方HPFEEDS共享T-Pot数据提供额外的选项来提交攻击数据，例如SISSDEN。如果您想分享您的T-Pot数据，您只需在第三方经纪人处注册一个帐户，并为社区带来好处。注册后，您将收到您的凭证，以便与社区分 创建账户并申请凭证 https://portal.sissden.eu/profile 运行脚本./hpfreeds_option.sh 系统使用 系统监控web https://yourip:64294 管理web https://yourip:64297 ssh登陆 ssh -l tsec -p 64295 yourip 公网收集数据可以使用内网穿透工具将需要收集信息的端口转发出去，可以参考 https://www.izhuhn.cn/index.php/2019/05/22/%e8%87%aa%e5%bb%bangrok%e5%86%85%e7%bd%91%e7%a9%bf%e9%80%8f%e6%9c%8d%e5%8a%a1/ 更新 备份重要文件 执行更新命令cd /opt/tpot ./update.sh 部署视频https://player.youku.com/embed/XNDE5NDAyMDEwMA==]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[centos7 debian9 ubuntu16.04 修改IP及DNS]]></title>
    <url>%2F2019%2F07%2F15%2F%E4%BF%AE%E6%94%B9IP%E5%8F%8ADNS%2F</url>
    <content type="text"><![CDATA[centos7修改ip地址 ifconfig 找出网卡的名称 查看网卡为ens33 cd /etc/sysconfig/network-scripts/ —- 查看 vim ifcfg-ens33 TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=none DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens33 UUID=c886ea74-29f0-487c-9947-34345f1d3623 DEVICE=ens33 #设置开机自启 ONBOOT=yes #配置IP地址信息 IPADDR=192.168.100.90 NETMASK=255.255.255.0 GATEWAY=192.168.100.1 #取消NetworkManager管理 NM_CONTROLLED=no 重启网络服务 systemctl restart network 配置DNS vim /etc/NetworkManager/NetworkManager.conf 在[main]中添加 dns=no 修改resolv.conf配置文件 vim /etc/resolv.conf 添加 #主DNS服务器 nameserver 218.85.157.99 #备DNS服务器 nameserver 114.114.114.114 重启NetworkManagersystemctl restart NetworkManager debian9修改IP地址： 编辑文件 vim /etc/network/interfaces 设置静态IP auto lo iface lo inet lookback auto eth0 iface eth0 inet static #将网卡eth0设置为获取静态地址 address 192.168.1.10 #替换为自己的IP地址 netmask 255.255.255.0 #替换为自己的子网掩码 gateway 192.168.1.1 #替换为自己的网关地址 设置为DHCP自动获取IP auto lo iface lo inet loopback auto eth0 iface eth0 inet dhcp #将网卡eth0设置为自动获取IP 重启网卡服务 debian8 systemctl restart network debian9 service networking restart 修改DNS 编辑文件vim /etc/resolv.conf 添加DNSnameserver 114.114.114.114 #替换为自己的DNS服务器地址 查询IP及测试网络连通 debian8ifconfig debian9ip addr 2.测试网络连通ping www.baidu.com ubuntu16.04修改IP地址 编辑文件sudo vim /etc/network/interfaces auto eth0 #要设置的网卡 iface eth0 inet static #设置静态IP；如果是使用自动IP用dhcp，后面的不用设置，一般少用 addressxxx.xxx.xxx.xxx #IP地址 netmaskxxx.xxx.xxx.xxx #子网掩码 gatewayxxx.xxx.xxx.xxx #网关 修改DNS 编辑sudo vim /etc/resolv.conf 上面设置的文件重启后会覆盖，如果要持久的保存，需要修改：/etc/resolvconf/resolv.conf.d/base nameserver 172.16.3.4 #希望修改成的DNS nameserver 172.16.3.3 #希望修改成的DNS 先运行一次，然后在rc.local里加入这个重启网络配置的命令： sudo /etc/init.d/networking restart #使网卡配置生效 sudo /etc/init.d/resolvconf restart #使DNS生效]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[高质量服务器]]></title>
    <url>%2F2019%2F07%2F10%2F%E5%87%BA%E5%94%AE%E9%AB%98%E8%B4%A8%E9%87%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[服务器免费测试地址 服务器系统 服务器ip ssh端口 用户名 root密码均为rabbit centos7 fwq.geekrabbit.xyz 522 root rabbit ubuntu16.04 fwq.geekrabbit.xyz 544 log rabbit debian9 fwq.geekrabbit.xyz 566 debian rabbit 测试机硬件配置 均为1核 512m 128g硬盘 100m带宽 数量有限售完为止 有意者加我微信：1347896323 价格表 数量有限售完为止特价 核心数 内存 硬盘 带宽 月租/元 1核 512m 128g 100m 10 2核 512m 128g 100m 15 3核 512m 128g 100m 20 4核 512m 128g 100m 25 5核 512m 128g 100m 30 6核 512m 128g 100m 35 7核 512m 128g 100m 40 8核 512m 128g 100m 45 9核 512m 128g 100m 50 10核 512m 128g 100m 55 11核 512m 128g 100m 60 12核 512m 128g 100m 65 1g内存 核心数 内存 硬盘 带宽 月租/元 1核 1g 128g 100m 20 2核 1g 128g 100m 25 3核 1g 128g 100m 30 4核 1g 128g 100m 35 5核 1g 128g 100m 40 6核 1g 128g 100m 45 7核 1g 128g 100m 50 8核 1g 128g 100m 55 9核 1g 128g 100m 60 10核 1g 128g 100m 65 11核 1g 128g 100m 70 12核 1g 128g 100m 75 1.5g内存 核心数 内存 硬盘 带宽 月租/元 1核 1.5g 128g 100m 30 2核 1.5g 128g 100m 35 3核 1.5g 128g 100m 40 4核 1.5g 128g 100m 45 5核 1.5g 128g 100m 50 6核 1.5g 128g 100m 55 7核 1.5g 128g 100m 60 8核 1.5g 128g 100m 65 9核 1.5g 128g 100m 70 10核 1.5g 128g 100m 75 11核 1.5g 128g 100m 80 12核 1.5g 128g 100m 85 2.0g内存 核心数 内存 硬盘 带宽 月租/元 1核 2g 128g 100m 40 2核 2g 128g 100m 45 3核 2g 128g 100m 50 4核 2g 128g 100m 55 5核 2g 128g 100m 60 6核 2g 128g 100m 65 7核 2g 128g 100m 70 8核 2g 128g 100m 75 9核 2g 128g 100m 80 10核 2g 128g 100m 85 11核 2g 128g 100m 90 12核 2g 128g 100m 95 2.5g内存 核心数 内存 硬盘 带宽 月租/元 1核 2.5g 128g 100m 50 2核 2.5g 128g 100m 55 3核 2.5g 128g 100m 60 4核 2.5g 128g 100m 65 5核 2.5g 128g 100m 70 6核 2.5g 128g 100m 75 7核 2.5g 128g 100m 80 8核 2.5g 128g 100m 85 9核 2.5g 128g 100m 90 10核 2.5g 128g 100m 95 11核 2.5g 128g 100m 100 12核 2.5g 128g 100m 105 3.0g内存 核心数 内存 硬盘 带宽 月租/元 1核 3g 128g 100m 60 2核 3g 128g 100m 65 3核 3g 128g 100m 70 4核 3g 128g 100m 75 5核 3g 128g 100m 80 6核 3g 128g 100m 85 7核 3g 128g 100m 90 8核 3g 128g 100m 95 9核 3g 128g 100m 100 10核 3g 128g 100m 105 11核 3g 128g 100m 110 12核 3g 128g 100m 115 3.5g内存 核心数 内存 硬盘 带宽 月租/元 1核 3.5g 128g 100m 70 2核 3.5g 128g 100m 75 3核 3.5g 128g 100m 80 4核 3.5g 128g 100m 85 5核 3.5g 128g 100m 90 6核 3.5g 128g 100m 95 7核 3.5g 128g 100m 100 8核 3.5g 128g 100m 105 9核 3.5g 128g 100m 110 10核 3.5g 128g 100m 115 11核 3.5g 128g 100m 120 12核 3.5g 128g 100m 125 4.0g内存 核心数 内存 硬盘 带宽 月租/元 1核 4g 128g 100m 80 2核 4g 128g 100m 85 3核 4g 128g 100m 90 4核 4g 128g 100m 95 5核 4g 128g 100m 100 6核 4g 128g 100m 105 7核 4g 128g 100m 110 8核 4g 128g 100m 115 9核 4g 128g 100m 120 10核 4g 128g 100m 125 11核 4g 128g 100m 130 12核 4g 128g 100m 135 4.5g内存 核心数 内存 硬盘 带宽 月租/元 1核 4.5g 128g 100m 90 2核 4.5g 128g 100m 95 3核 4.5g 128g 100m 100 4核 4.5g 128g 100m 105 5核 4.5g 128g 100m 110 6核 4.5g 128g 100m 115 7核 4.5g 128g 100m 120 8核 4.5g 128g 100m 125 9核 4.5g 128g 100m 130 10核 4.5g 128g 100m 135 11核 4.5g 128g 100m 140 12核 4.5g 128g 100m 145 5.0g内存 核心数 内存 硬盘 带宽 月租/元 1核 5g 128g 100m 100 2核 5g 128g 100m 105 3核 5g 128g 100m 110 4核 5g 128g 100m 115 5核 5g 128g 100m 120 6核 5g 128g 100m 125 7核 5g 128g 100m 130 8核 5g 128g 100m 135 9核 5g 128g 100m 140 10核 5g 128g 100m 145 11核 5g 128g 100m 150 12核 5g 128g 100m 155 5.5g内存 核心数 内存 硬盘 带宽 月租/元 1核 5.5g 128g 100m 110 2核 5.5g 128g 100m 115 3核 5.5g 128g 100m 120 4核 5.5g 128g 100m 125 5核 5.5g 128g 100m 130 6核 5.5g 128g 100m 135 7核 5.5g 128g 100m 140 8核 5.5g 128g 100m 145 9核 5.5g 128g 100m 150 10核 5.5g 128g 100m 155 11核 5.5g 128g 100m 160 12核 5.5g 128g 100m 165 6.0g内存 核心数 内存 硬盘 带宽 月租/元 1核 6g 128g 100m 120 2核 6g 128g 100m 125 3核 6g 128g 100m 130 4核 6g 128g 100m 135 5核 6g 128g 100m 140 6核 6g 128g 100m 145 7核 6g 128g 100m 150 8核 6g 128g 100m 155 9核 6g 128g 100m 160 10核 6g 128g 100m 165 11核 6g 128g 100m 170 12核 6g 128g 100m 175 6.5g内存 核心数 内存 硬盘 带宽 月租/元 1核 6.5g 128g 100m 130 2核 6.5g 128g 100m 135 3核 6.5g 128g 100m 140 4核 6.5g 128g 100m 145 5核 6.5g 128g 100m 150 6核 6.5g 128g 100m 155 7核 6.5g 128g 100m 160 8核 6.5g 128g 100m 165 9核 6.5g 128g 100m 170 10核 6.5g 128g 100m 175 11核 6.5g 128g 100m 180 12核 6.5g 128g 100m 185 7.0g内存 核心数 内存 硬盘 带宽 月租/元 1核 7g 128g 100m 140 2核 7g 128g 100m 145 3核 7g 128g 100m 150 4核 7g 128g 100m 155 5核 7g 128g 100m 160 6核 7g 128g 100m 165 7核 7g 128g 100m 170 8核 7g 128g 100m 175 9核 7g 128g 100m 180 10核 7g 128g 100m 185 11核 7g 128g 100m 190 12核 7g 128g 100m 195 7.5g内存 核心数 内存 硬盘 带宽 月租/元 1核 7.5g 128g 100m 150 2核 7.5g 128g 100m 155 3核 7.5g 128g 100m 160 4核 7.5g 128g 100m 165 5核 7.5g 128g 100m 170 6核 7.5g 128g 100m 175 7核 7.5g 128g 100m 180 8核 7.5g 128g 100m 185 9核 7.5g 128g 100m 190 10核 7.5g 128g 100m 195 11核 7.5g 128g 100m 200 12核 7.5g 128g 100m 205 8.0g内存 核心数 内存 硬盘 带宽 月租/元 1核 8g 128g 100m 160 2核 8g 128g 100m 165 3核 8g 128g 100m 170 4核 8g 128g 100m 175 5核 8g 128g 100m 180 6核 8g 128g 100m 185 7核 8g 128g 100m 190 8核 8g 128g 100m 195 9核 8g 128g 100m 200 10核 8g 128g 100m 205 11核 8g 128g 100m 210 12核 8g 128g 100m 215]]></content>
  </entry>
  <entry>
    <title><![CDATA[parrot安装完成后的部署]]></title>
    <url>%2F2019%2F07%2F06%2Fparrot%E5%AE%89%E8%A3%85%E5%AE%8C%E6%88%90%E5%90%8E%E7%9A%84%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[配置SSH安装sshsudo apt install ssh 编辑sshd_config文件sudo vi /etc/ssh/sshd_config 设置允许密码登陆将 #PasswordAuthentication yes ` 前面的注释符去掉 设置允许root登陆(不建议)将sshd_config文件中的语句 #PermitRootLogin prohibit-password 修改为： PermitRootLogin yes 并去掉前面的注释符 保存文件,启动SSH服务 sudo systemctl start ssh 或重启ssh服务 sudo systemctl restart ssh 设置SSH开机自启动sudo systemctl enable ssh 换源首先在终端中输入这条命令(以管理员身份)打开源文件： sudo vi /etc/apt/sources.list.d/parrot.list 然后添加源 (我用着两个） deb http://mirrors.ustc.edu.cn/parrot/ parrot main contrib non-free deb http://mirrors.tuna.tsinghua.edu.cn/parrot/ parrot main contrib non-free 由于Parrot Security支持的源很多，我们又是在国内，我重点说一下Parrot Security中国国内的镜像源有哪些？ 1、中国科技大学和USTCLUG deb http://mirrors.ustc.edu.cn/parrot parrot main contrib non-free 2、TUNA（北京清华大学，TUNA协会） deb https://mirrors.tuna.tsinghua.edu.cn/parrot/ parrot main contrib non-free 3、SHU（上海大学） deb https://mirrors.shu.edu.cn/parrot/ parrot main contrib non-free 4、SJTUG（上海交通大学* NIX用户组） deb https://mirrors.sjtug.sjtu.edu.cn/parrot/ parrot main contrib non-free]]></content>
      <tags>
        <tag>学习经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机web化管理工具-jimv]]></title>
    <url>%2F2019%2F06%2F22%2F%E8%99%9A%E6%8B%9F%E6%9C%BAweb%E5%8C%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-jimv%2F</url>
    <content type="text"><![CDATA[jimv是什么jimv是基于kvm进行开发，从而对其主要功能进行web化对接，各方面功能也都还是相当优秀的，结构清晰简单，易于部署、维护、使用的，低门槛企业私有云管理平台。相比于业界知名的 OpenStack、OpenNebula…，JimV 没有很多的零部件，不需要庞大的维护团队。 VMWare部署思路和教程思路 由于 VMWare 默认不支持 iPXE，可以下载 ipxe.iso 镜像变通达成目的 配置好后就开始下载centos7,差不多20分钟左右。 系统安装好后，jimv也就部署好了，直接浏览器（最好用谷歌浏览器）访问他的IP 直接初始化，在往jimv服务器里导入系统模板，配置ip池，创建磁盘，最后创建虚拟机，也就是虚拟机里安装虚拟机 教程 由于 VMWare 默认不支持 iPXE，大家可以下载 ipxe.iso 镜像变通达成目的。进入黑屏后按ctrl+b,大概20分钟自动部署完成。 上传系统镜像模板 模板地址存放系统模板到，任意一个计算节点的 /opt/template_images 目录下即可。该目录已经自动做好了计算节点间的 NFS 共享。 创建虚拟机模板在 JimV-C 控制面板，模板镜像中添加虚拟机模板。 添加 IP 池在 JimV-C 控制面板，系统配置中添加 IP 池。（添加的IP一定要和jimv在一个网段，否则无法上网） 享受”简单、快速开”创虚拟机实例的快乐。。。。 本次教程参考jimv正微官方网站本次搭建踩到了很多的坑，是jimv的官方qq群：377907881 的群主对我提供了很多帮助，要不然又要浪费好多的时间去琢磨了，在这里我表示感谢。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库插入和删除表数据（八）]]></title>
    <url>%2F2019%2F06%2F21%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%92%E5%85%A5%E5%92%8C%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%EF%BC%88%E5%85%AB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[MySQL 插入数据INSERT INTO table_name ( field1, field2,...fieldN ) VALUES ( value1, value2,...valueN ); mysql&gt; show columns from runoob_tbl; +-----------------+------------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +-----------------+------------------+------+-----+---------+----------------+ | runoob_id | int(10) unsigned | NO | PRI | NULL | auto_increment | | runoob_title | varchar(100) | NO | | NULL | | | runoob_author | varchar(40) | NO | | NULL | | | submission_date | date | YES | | NULL | | +-----------------+------------------+------+-----+---------+----------------+ mysql&gt; insert into runoob_tbl -&gt; (runoob_title, runoob_author, submission_date) -&gt; values -&gt; (&quot;学习 mysql&quot;, &quot;好简单&quot;, NOW()); Query OK, 1 row affected, 1 warning (0.13 sec) mysql&gt; select * from runoob_tbl -&gt; ; +-----------+--------------+---------------+-----------------+ | runoob_id | runoob_title | runoob_author | submission_date | +-----------+--------------+---------------+-----------------+ | 2 | 学习 mysql | 好简单 | 2019-06-21 | +-----------+--------------+---------------+-----------------+]]></content>
      <categories>
        <category>MySQL数据库学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库创建与删除表（七）]]></title>
    <url>%2F2019%2F06%2F17%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%A0%E9%99%A4%E8%A1%A8%EF%BC%88%E4%B8%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[创建MySQL数据表： 表名 表字段名 定义每个表字段 语法CREATE TABLE table_name (column_name column_type); root@host# mysql -u root -p Enter password:******* mysql&gt; use RUNOOB; Database changed mysql&gt; CREATE TABLE runoob_tbl( -&gt; runoob_id INT NOT NULL AUTO_INCREMENT, -&gt; runoob_title VARCHAR(100) NOT NULL, -&gt; runoob_author VARCHAR(40)NOT NULL, -&gt; submission_date DATE, -&gt; PRIMARY KEY( runoob_id ) -&gt; )ENGINE=InnoDB DEFAULT CHARSET=utf8; Query OK, 0 rows affected (0.16 sec) 将在 RUNOOB 数据库中创建数据表runoob_tbl： CREATE TABLE IF NOT EXISTS `runoob_tbl`( `runoob_id` INT UNSIGNED AUTO_INCREMENT, `runoob_title` VARCHAR(100) NOT NULL, `runoob_author` VARCHAR(40) NOT NULL, `submission_date` DATE, PRIMARY KEY ( `runoob_id` ) )ENGINE=InnoDB DEFAULT CHARSET=utf8; 如果不想字段为 NULL 可以设置字段的属性为 NOT NULL， 在操作数据库时如果输入该字段的数据为NULL ，就会报错。 AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。 PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。 ENGINE 设置存储引擎，CHARSET 设置编码。 MySQL 删除数据表DROP TABLE 表名 ; 删除了数据表runoob_tbl: root@host# mysql -u root -p Enter password:******* mysql&gt; use RUNOOB; Database changed mysql&gt; DROP TABLE runoob_tbl Query OK, 0 rows affected (0.8 sec)]]></content>
      <categories>
        <category>MySQL数据库学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库数据类型（六）]]></title>
    <url>%2F2019%2F06%2F16%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[MySQL 数据类型MySQL中定义数据字段的类型对你数据库的优化是非常重要的。 MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。 数值类型MySQL支持所有标准SQL数值数据类型。 这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。 关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。 BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。 作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 字节 (-128，127) (0，255) 小整数值 SMALLINT 2 字节 (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 字节 (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 字节 (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 BIGINT 8 字节 (-9,223,372,036,854,775,808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 FLOAT 4 字节 (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(1.175 494 351 E-38，3.402 823 466 E+38) 单精度浮点数值 DOUBLE 8 字节 (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 双精度浮点数值 DECIMAL 对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2 依赖于M和D的值 依赖于M和D的值 小数值 日期和时间类型表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。 每个时间类型有一个有效值范围和一个&quot;零&quot;值，当指定不合法的MySQL不能表示的值时使用&quot;零&quot;值。 类型 大小(字节) 范围 格式 用途 DATE 3 1000-01-01/9999-12-31 YYYY-MM-DD 日期值 TIME 3 ‘-838:59:59’/‘838:59:59’ HH:MM:SS 时间值或持续时间 YEAR 1 1901/2155 YYYY 年份值 DATETIME 8 1000-01-01 00:00:00/9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:00/2038结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 YYYYMMDD HHMMSS 混合日期和时间值，时间戳 字符串类型字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。这些类型如何工作以及如何在查询中使用这些类型。 类型 大小 用途 CHAR 0-255字节 定长字符串 VARCHAR 0-65535 字节 变长字符串 TINYBLOB 0-255字节 不超过 255 个字符的二进制字符串 TINYTEXT 0-255字节 短文本字符串 BLOB 0-65 535字节 二进制形式的长文本数据 TEXT 0-65 535字节 长文本数据 MEDIUMBLOB 0-16 777 215字节 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215字节 中等长度文本数据 LONGBLOB 0-4 294 967 295字节 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295字节 极大文本数据 CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。 BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。 BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。 有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。 笔记整型 MySQL数据类型 含义（有符号） tinyint(m) 1个字节 范围(-128~127) smallint(m) 2个字节 范围(-32768~32767) mediumint(m) 3个字节 范围(-8388608~8388607) int(m) 4个字节 范围(-2147483648~2147483647) bigint(m) 8个字节 范围(+-9.22* 10的18次方) （M）中的M表示数据显示的宽度，与实际存储的长度无关。 1、也就是int（3）和int（11）能够存储的数据是一样的，都是从`-2147483648`到`2147483647（或者0-`4294967295`）。 2、int（M）只有联合zerofill参数才能有意义，否则int（3）和int（11）没有任何区别。]]></content>
      <categories>
        <category>MySQL数据库学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库创建与删除库（五）]]></title>
    <url>%2F2019%2F06%2F15%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%A0%E9%99%A4%E5%BA%93(%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[MySQL 创建数据库create database 库名; mysql&gt; create database hello; Query OK, 1 row affected (0.00 sec) MySQL 删除数据库drop database 库名; mysql&gt; drop database hello; Query OK, 0 rows affected (0.16 sec)]]></content>
      <categories>
        <category>MySQL数据库学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[拒接服务介绍和DoS分类（一）]]></title>
    <url>%2F2019%2F06%2F15%2F%E6%8B%92%E6%8E%A5%E6%9C%8D%E5%8A%A1%E4%BB%8B%E7%BB%8D%E5%92%8CDoS%E5%88%86%E7%B1%BB%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[什么是DDOSDDOS是（Distributed Denial of Service）的缩写，即分布式阻断服务，黑客利用入侵到的傀儡主机攻击来达到“妨碍正常使用者使用服务”的目的，这样就形成了DDOS攻击，随着互联网的不断发展，竞争越来越激烈，各式各样的DDOS攻击开始出现。 拒绝服务 DOS不是DoS DoS(Denial of Service)拒接服务，利用程序漏洞或一对一的资源消耗 DDOS分布式拒绝服务 多对一的攻击汇聚资源能力，重点在于量大，属于资源消耗型 历史 以前：欠缺技术的无赖，我ping死你（最难缠的无赖） 现在：最强大最危险的攻击，攻击方式众多 DoS分类 网络基于巨量的flood耗尽目标的网络带宽的资源消耗ICMP Flood 、UDP Flood 协议攻击协议漏洞发起的拒绝服务攻击syn flood 、ping of Death 、ARP 、DNS 、802.11 、SSL 应用1.针对应用软件和操作系统漏洞发起的拒绝服务攻击2.大量频繁访问消耗系统资源严重的应用（cc)3.通产表现为操作系统运行正常，网络流量不大，但服务停止响应 为何会被DoS 从攻击者到被害者-网络——&gt;FW——&gt;服务器os——&gt;服务应用 资源消耗-网络：带宽-FW：吞吐量、并发连接-服务器：CPU、内存、I/O-应用：处理请求能力，对os资源的使用权 程序漏洞攻击-缓冲区溢出-协议、程序逻辑漏洞 链路上任何一点都可成为目标 草图]]></content>
      <categories>
        <category>DDOS攻防学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库连接与管理（四）]]></title>
    <url>%2F2019%2F06%2F13%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E4%B8%8E%E7%AE%A1%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[使用Linux连接mysql服务器从命令行中本地连接mysql服务器 [root@hhost]# mysql -u root -p sh 远程登陆MySQL [root@hhost]# mysql -h 服务器IP -u root 登录成功后会出现 mysql&gt; 命令提示窗口 显示所有数据库，注意后面的；mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | test | +--------------------+ 2 rows in set (0.10 sec) 连接数据库use 数据库名 查看表mysql&gt; show tables; +----------------+ | Tables_in_test | +----------------+ | runoob_tbl | | sys_menu | +----------------+ 2 rows in set (0.00 sec) 查表所有内容select * from 表名; 显示表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息show columns from 数据表; mysql&gt; show columns from runoob_tbl; +-----------------+------------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +-----------------+------------------+------+-----+---------+----------------+ | runoob_id | int(10) unsigned | NO | PRI | NULL | auto_increment | | runoob_title | varchar(100) | NO | | NULL | | | runoob_author | varchar(40) | NO | | NULL | | | submission_date | date | YES | | NULL | | +-----------------+------------------+------+-----+---------+----------------+ 4 rows in set (0.06 sec) 显示数据表的详细索引信息，包括PRIMARY KEY（主键）。show index from runoob_tbl; mysql&gt; show index from runoob_tbl; +------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | +------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | runoob_tbl | 0 | PRIMARY | 1 | runoob_id | A | 0 | NULL | NULL | | BTREE | | | +------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ 1 row in set (0.00 sec) 显示数据库test中的所有表信息show table status from 库名; mysql&gt; show table status from test; +------------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+-------------+------------+-----------------+----------+----------------+---------+ | Name | Engine | Version | Row_format | Rows | Avg_row_length | Data_length | Max_data_length | Index_length | Data_free | Auto_increment | Create_time | Update_time | Check_time | Collation | Checksum | Create_options | Comment | +------------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+-------------+------------+-----------------+----------+----------------+---------+ | runoob_tbl | InnoDB | 10 | Compact | 0 | 0 | 16384 | 0 | 0 | 0 | 1 | 2019-06-05 14:57:14 | NULL | NULL | utf8_general_ci | NULL | | | | sys_menu | InnoDB | 10 | Compact | 0 | 0 | 16384 | 0 | 0 | 0 | 1 | 2019-06-03 09:54:08 | NULL | NULL | utf8_general_ci | NULL | | 菜单 | +------------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+-------------+------------+-----------------+----------+----------------+---------+ 2 rows in set (0.00 sec) 表名以runoob开头的表的信息show table status from 库名 like &#39;表名%&#39;; mysql&gt; show table status from test like &#39;runoob%&#39;; +------------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+-------------+------------+-----------------+----------+----------------+---------+ | Name | Engine | Version | Row_format | Rows | Avg_row_length | Data_length | Max_data_length | Index_length | Data_free | Auto_increment | Create_time | Update_time | Check_time | Collation | Checksum | Create_options | Comment | +------------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+-------------+------------+-----------------+----------+----------------+---------+ | runoob_tbl | InnoDB | 10 | Compact | 0 | 0 | 16384 | 0 | 0 | 0 | 1 | 2019-06-05 14:57:14 | NULL | NULL | utf8_general_ci | NULL | | | +------------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+-------------+------------+-----------------+----------+----------------+---------+ 1 row in set (0.00 sec) 加上 \G，查询结果按列打印show table status from 库名 like &#39;表名%&#39;\G; mysql&gt; show table status from test like &#39;runoob%&#39;\G; *************************** 1. row *************************** Name: runoob_tbl Engine: InnoDB Version: 10 Row_format: Compact Rows: 0 Avg_row_length: 0 Data_length: 16384 Max_data_length: 0 Index_length: 0 Data_free: 0 Auto_increment: 1 Create_time: 2019-06-05 14:57:14 Update_time: NULL Check_time: NULL Collation: utf8_general_ci Checksum: NULL Create_options: Comment: 1 row in set (0.00 sec) ERROR: No query specified]]></content>
      <categories>
        <category>MySQL数据库学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库开启与关闭（三）]]></title>
    <url>%2F2019%2F06%2F12%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%90%AF%E4%B8%8E%E5%85%B3%E9%97%AD%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[启动方式1、使用linux命令service 启动： service mysqld start 2、使用 mysqld 脚本启动： /etc/inint.d/mysqld start 3、使用 safe_mysqld 启动： safe_mysqld&amp; 停止方式1、使用 service 启动： service mysqld stop 2、使用 mysqld 脚本启动： /etc/inint.d/mysqld stop 3、 mysqladmin shutdown 重启方式1、使用 service 启动： service mysqld restart 2、使用 mysqld 脚本启动： /etc/inint.d/mysqld restart 查看mysql端口是否已经使用，使用netstat -anp 命令查看服务器端口使用情况]]></content>
      <categories>
        <category>MySQL数据库学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库安装（二）]]></title>
    <url>%2F2019%2F06%2F12%2FMySQL%E6%95%B0%E6%8D%AEcentos%E5%AE%89%E8%A3%85%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Linux上安装MySQL安装前，我们可以检测系统是否自带安装 MySQL: rpm -qa | grep mysql 如果系统有安装，那可以选择进行卸载 rpm -e mysql // 普通删除模式 rpm -e --nodeps mysql // 强力删除模式，如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除 Centos7安装 MySQL：Centos7 系统下使用 yum 命令安装 MySQL，需要注意的是 CentOS 7 版本中 MySQL数据库已从默认的程序列表中移除，所以在安装前我们需要先去官网下载 Yum 资源包，下载地址为：https://dev.mysql.com/downloads/repo/yum/ https://dev.mysql.com/downloads/repo/yum/ wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm rpm -ivh mysql-community-release-el7-5.noarch.rpm yum update yum install mysql-server 权限设置： chown mysql:mysql -R /var/lib/mysql 初始化 MySQL： mysqld --initialize 启动 MySQL： systemctl start mysqld 查看 MySQL 运行状态： systemctl status mysqld mariadb数据库的相关命令是： systemctl start mariadb #启动MariaDB systemctl stop mariadb #停止MariaDB systemctl restart mariadb #重启MariaDB systemctl enable mariadb #设置开机启动 验证 MySQL 安装使用 mysqladmin 工具来获取服务器状态： [root@host]# mysqladmin --version linux上该命令将输出以下结果，该结果基于你的系统信息： mysqladmin Ver 8.23 Distrib 5.0.9-0, for redhat-linux-gnu on i386 如果以上命令执行后未输出任何信息，说明Mysql未安装成功。 Mysql安装后Mysql安装成功后，默认的root用户密码为空，你可以使用以下命令来创建root用户的密码： [root@host]# mysqladmin -u root password &quot;new_password&quot;; 连接到Mysql服务器： [root@host]# mysql -u root -p Enter password:*******]]></content>
      <categories>
        <category>MySQL数据库学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库 初学（一）]]></title>
    <url>%2F2019%2F06%2F11%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%AD%A6%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[什么是数据库？数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。每个数据库都有一个或多个不同的 API 用于创建，访问，管理，搜索和复制所保存的数据。我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理的大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。RDBMS 即关系数据库管理系统(Relational Database Management System)的特点： 1.数据以表格的形式出现 2.每行为各种记录名称 3.每列为记录名称所对应的数据域 4.许多的行和列组成一张表单 5.若干的表单组成database RDBMS 术语 数据库: 数据库是一些关联表的集合。 数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。 列: 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。 行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。 冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。 主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。 外键：外键用于关联两个表。 复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。 索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。 参照完整性: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。 表头(header): 每一列的名称; 列(col): 具有相同数据类型的数据的集合; 行(row): 每一行用来描述某条记录的具体信息; 值(value): 行的具体信息, 每个值必须与该列的数据类型相同; 键(key): 键的值在当前列中具有唯一性。 MySQL数据库MySQL 是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。 MySQL 是开源的，所以你不需要支付额外的费用。 MySQL 支持大型的数据库。可以处理拥有上千万条记录的大型数据库。 MySQL 使用标准的 SQL 数据语言形式。 MySQL 可以运行于多个系统上，并且支持多种语言。这些编程语言包括 C、C++、Python、Java、Perl、PHP、Eiffel、Ruby 和 Tcl 等。 MySQL 对PHP有很好的支持，PHP 是目前最流行的 Web 开发语言。 MySQL 支持大型数据库，支持 5000 万条记录的数据仓库，32 位系统表文件最大可支持 4GB，64 位系统支持最大的表文件为8TB。 MySQL 是可以定制的，采用了 GPL 协议，你可以修改源码来开发自己的 MySQL 系统。]]></content>
      <categories>
        <category>MySQL数据库学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[中兴光猫修改mac和sn]]></title>
    <url>%2F2019%2F05%2F17%2F%E4%B8%AD%E5%85%B4%E5%85%89%E7%8C%AB%E4%BF%AE%E6%94%B9mac%E5%92%8Csn%2F</url>
    <content type="text"><![CDATA[我们更换光猫的时候因为loid不同不能入网；本经验教程将教大家如何修改中兴光猫F620的loid与mac地址这类的信息； 废话不多说 工具 中兴光猫F620 网线 电脑方法1.电脑通过网线连接光猫的LAN口任意一端口；电脑ip设置为自动获取ip地址；2.电脑上我们找到计算机上的windows键盘，使用win+R的按键组合来打开运行；在运行输入框内输入CMD3.进入路由器 telnet 192.168.1.1 用户名密码:root Zte5214.修改SN: setmac 1 2177 xxxxxxxx [SN为8字符] 修改设备标识: setmac 1 512 xxxxxxxxxxxxxxxxx [设备标识位17位字符]修改MAC地址:setmac 1 256 00:00:00:00:00:00setmac 1 257 00:00:00:00:00:00setmac 1 258 00:00:00:00:00:00setmac 1 259 00:00:00:00:00:00setmac 1 260 00:00:00:00:00:00以上命令输入 setmac 2 xxx 为查看（此处xxx为编码的ID号如256、512、2177）。( e3 z0 R1 n3 o需要注意的是，SN和设备标识一定要输入大写字母，mac输入小写字母，我在这里浪费好多功夫，大意了（因为SN和设备标识用setmac 2 xxx命令查询出来不是明文，是unicode 16进制编码！！！）。。。还有就是mac其实一直到262都还有，不过其实一般来说itms验证只绑定设备标识，虽说我是SN、设备标识、mac全都改了。。。另外，还给个福利，SN号其实有两个，2177是8位，还有个2178是9位，前面有个大写的G，就跟包装盒和设备上面条码印的一样。]]></content>
      <categories>
        <category>搞机笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Centos搭建Ngrok实现内网穿透]]></title>
    <url>%2F2019%2F05%2F11%2FCentos%E6%90%AD%E5%BB%BANgrok%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%2F</url>
    <content type="text"><![CDATA[前言：原来一直用的别人搭建的内网穿透，因为是免费的，所以网速，稳定性都特别差，所以打算自己搭建一个属于自己的内网穿透 1、准备一台云服务器,一个域名,并且域名泛解析解析到云服务器,此处我用的服务器的操作系统为CentOS7(amd64) 2、安装环境安装gcc和git（用于下载ngrok源码） yum install gcc -y yum install git -y 3、安装go语言环境yum install -y mercurial git bzr subversion golang golang-pkg-windows-amd64 golang-pkg-windows-386 4、检查环境安装git --version //( &gt;= 1.7 ) go version 5、在服务器上搭建Ngrok服务5.1.下载ngrok源码 git clone https://github.com/inconshreveable/ngrok.git 5.2.生成证书 cd ngrok abc.com这里修改为自己的域名,命令一条一条复制即可 export NGROK_DOMAIN=&quot;abc.com&quot; openssl genrsa -out rootCA.key 2048 openssl req -x509 -new -nodes -key rootCA.key -subj &quot;/CN=$NGROK_DOMAIN&quot; -days 5000 -out rootCA.pem openssl genrsa -out device.key 2048 openssl req -new -key device.key -subj &quot;/CN=$NGROK_DOMAIN&quot; -out device.csr openssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000 5.3.将新生成的证书替换，执行下面命令后 “y” 回车 一行一行执行代码！ cp rootCA.pem assets/client/tls/ngrokroot.crt cp device.crt assets/server/tls/snakeoil.crt cp device.key assets/server/tls/snakeoil.key 6、编译生成ngrokd（服务端）GOOS=linux GOARCH=amd64 make release-server ​ 生成在~/ngrok/bin/目录中 7、编译生成ngrok（客户端）GOOS=windows GOARCH=amd64 make release-client ​ 生成在~/ngrok/bin/windows_amd64/目录中 8、用SSH Secure Shell Client工具将~/ngrok/bin/windows_amd64/里的文件下载到本地Windows下，如D:\ngrok 9、在D:\ngrok中新建文件，改名为 ngrok.cfg文件中输入： server_addr: &quot;abc.com:8083&quot; trust_host_root_certs: false tunnels: http: subdomain: &quot;www&quot; proto: http: &quot;80&quot; https: subdomain: &quot;www&quot; proto: https: &quot;443&quot; ssh: remote_port: 2222 proto: tcp: &quot;22&quot; mstsc: remote_port: 52222 proto: tcp: &quot;192.168.0.107:3389&quot; 以上 8083 80 443 与 远程开启的端口一致， 10、开启远程服务在ngrok目录中 cd ngrok sudo ./bin/ngrokd -domain=&quot;abc.com&quot; -httpAddr=&quot;:80&quot; -httpsAddr=&quot;:443&quot; -tunnelAddr=&quot;:8083&quot; &amp; 这里的端口号与config文件对应，视情况而定 [16:05:23 CST 2018/01/09][INFO] (ngrok/log.(*PrefixLogger).Info:83) [registry][tun] No affinity cache specified [16:05:23 CST 2018/01/09][INFO] (ngrok/log.Info:112) Listening for public http connections on [::]:80 [16:05:23 CST 2018/01/09][INFO] (ngrok/log.Info:112) Listening for public https connections on [::]:443 [16:05:23 CST 2018/01/09][INFO] (ngrok/log.Info:112) Listening for control and proxy connections on [::]:8083 [16:05:23 CST 2018/01/09][INFO] (ngrok/log.(*PrefixLogger).Info:83) [metrics] Reporting every 30 seconds 显示此为成功开启 如果有关闭终端，相关程序就被杀死的情况1.安装screenyum install -y screen 2.输入screen，然后输入你要运行的命令3.ctrl+A 然后按D，screen会关闭4.查看正在运行的程序screen -ls 现在关闭终端，在screen中的程序会继续后台运行 11、开启客户机服务在Windows中D:\ngrok新建文件 改名 start.bat 输入： ngrok -config=ngrok.cfg start http https ssh mstsc 直接双击运行 表示成功， 不成功的话看看自己的开启端口是否与config文件中对应 或查看服务器的远程端口是否在安全组中打开 ！！！这很重要！！！关于ngrok在远程开机自启问题 服务器后台开机启动运行ngrok服务端： 1.以下内容新建一个 start.sh 文件 放到 ~/ngrok/start.sh ~/ngrok/bin/ngrokd -domain=&quot;abc.com&quot; -httpAddr=&quot;:80&quot; -httpsAddr=&quot;:443&quot; -tunnelAddr=&quot;:8083&quot; &amp; 给权限： chmod 755 ~/ngrok/start.sh 2.新建ngrok启动脚本文件 sudo vi /etc/init.d/ngrok 文件内容： #!/bin/sh #chkconfig:2345 70 30 #description:ngrok BEGIN INIT INFO Provides: ngrok Required-Start: Required-Stop: Default-Start: 2 3 4 5 Default-Stop: 0 1 6 Short-Description: Start or stop the ngrok Proxy. END INIT INFO ngrok_path=~/ngrok/ case &quot;$1&quot; in start) echo &quot;start ngrok service..&quot; sh ${ngrok_path}/start.sh ;; *) exit 1 ;; esac 提示 : 运行sudo vi /etc/init.d/ngrok之后 ！！直接按键盘 I 进入编辑模式，然后复制下面内容 然后 “esc” “:” “wq” “!” “回车” 意思是保存退出！3.ngrok脚本文件 给权限 cd /etc/init.d chmod 755 ngrok 4.添加启动服务 ngrok chkconfig --add ngrok 5.测试服务是否能启动成功 service ngrok start 6.查看自启动的服务 是否有 nrgok ！！ chkconfig 执行这个代码如果出现后面的就OK了！！ ngrok 0:off 1:off 2:on 3:on 4:on 5:on 6:off 服务器ngrok的服务端开机自动启动成功了！！7.在此附上python版源码 #!/usr/bin/env python # -*- coding: UTF-8 -*- # 建议Python 2.7.9 或 Python 3.4.2 以上运行 # 项目地址: https://github.com/hauntek/python-ngrok # Version: v1.5 import socket import ssl import json import struct import random import sys import time import logging import threading host = &#39;tunnel.qydev.com&#39; # Ngrok服务器地址 port = 4443 # 端口 bufsize = 1024 # 吞吐量 Tunnels = list() # 全局渠道赋值 body = dict() body[&#39;protocol&#39;] = &#39;http&#39; body[&#39;hostname&#39;] = &#39;www.xxx.com&#39; body[&#39;subdomain&#39;] = &#39;&#39; body[&#39;rport&#39;] = 0 body[&#39;lhost&#39;] = &#39;127.0.0.1&#39; body[&#39;lport&#39;] = 80 Tunnels.append(body) # 加入渠道队列 body = dict() body[&#39;protocol&#39;] = &#39;http&#39; body[&#39;hostname&#39;] = &#39;&#39; body[&#39;subdomain&#39;] = &#39;xxx&#39; body[&#39;rport&#39;] = 0 body[&#39;lhost&#39;] = &#39;127.0.0.1&#39; body[&#39;lport&#39;] = 80 Tunnels.append(body) # 加入渠道队列 body = dict() body[&#39;protocol&#39;] = &#39;tcp&#39; body[&#39;hostname&#39;] = &#39;&#39; body[&#39;subdomain&#39;] = &#39;&#39; body[&#39;rport&#39;] = 55499 body[&#39;lhost&#39;] = &#39;127.0.0.1&#39; body[&#39;lport&#39;] = 22 Tunnels.append(body) # 加入渠道队列 reqIdaddr = dict() localaddr = dict() # 读取配置文件 if len(sys.argv) &gt;= 2: file_object = open(sys.argv[1]) try: all_the_text = file_object.read() config_object = json.loads(all_the_text) host = config_object[&quot;server&quot;][&quot;host&quot;] # Ngrok服务器地址 port = int(config_object[&quot;server&quot;][&quot;port&quot;]) # 端口 bufsize = int(config_object[&quot;server&quot;][&quot;bufsize&quot;]) # 吞吐量 Tunnels = list() # 重置渠道赋值 for Tunnel in config_object[&quot;client&quot;]: body = dict() body[&#39;protocol&#39;] = Tunnel[&quot;protocol&quot;] body[&#39;hostname&#39;] = Tunnel[&quot;hostname&quot;] body[&#39;subdomain&#39;] = Tunnel[&quot;subdomain&quot;] body[&#39;rport&#39;] = int(Tunnel[&quot;rport&quot;]) body[&#39;lhost&#39;] = Tunnel[&quot;lhost&quot;] body[&#39;lport&#39;] = int(Tunnel[&quot;lport&quot;]) Tunnels.append(body) # 加入渠道队列 del all_the_text del config_object except Exception: # logger = logging.getLogger(&#39;%s&#39; % &#39;config&#39;) # logger.error(&#39;The configuration file read failed&#39;) # exit(1) pass finally: file_object.close() mainsocket = 0 ClientId = &#39;&#39; pingtime = 0 def getloacladdr(Tunnels, Url): protocol = Url[0:Url.find(&#39;:&#39;)] hostname = Url[Url.find(&#39;//&#39;) + 2:] subdomain = hostname[0:hostname.find(&#39;.&#39;)] rport = Url[Url.rfind(&#39;:&#39;) + 1:] for tunnelinfo in Tunnels: if tunnelinfo.get(&#39;protocol&#39;) == protocol: if tunnelinfo.get(&#39;protocol&#39;) in [&#39;http&#39;, &#39;https&#39;]: if tunnelinfo.get(&#39;hostname&#39;) == hostname: return tunnelinfo if tunnelinfo.get(&#39;subdomain&#39;) == subdomain: return tunnelinfo if tunnelinfo.get(&#39;protocol&#39;) == &#39;tcp&#39;: if tunnelinfo.get(&#39;rport&#39;) == int(rport): return tunnelinfo return dict() def dnsopen(host): try: ip = socket.gethostbyname(host) except socket.error: return False return ip def connectremote(host, port): try: host = socket.gethostbyname(host) client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) ssl_client = ssl.wrap_socket(client, ssl_version=ssl.PROTOCOL_SSLv23) ssl_client.connect((host, port)) ssl_client.setblocking(1) logger = logging.getLogger(&#39;%s:%d&#39; % (&#39;Conn&#39;, ssl_client.fileno())) logger.debug(&#39;New connection to: %s:%d&#39; % (host, port)) except socket.error: return False return ssl_client def connectlocal(localhost, localport): try: localhost = socket.gethostbyname(localhost) client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client.connect((localhost, localport)) client.setblocking(1) logger = logging.getLogger(&#39;%s:%d&#39; % (&#39;Conn&#39;, client.fileno())) logger.debug(&#39;New connection to: %s:%d&#39; % (localhost, localport)) except socket.error: return False return client def NgrokAuth(): Payload = dict() Payload[&#39;ClientId&#39;] = &#39;&#39; Payload[&#39;OS&#39;] = &#39;darwin&#39; Payload[&#39;Arch&#39;] = &#39;amd64&#39; Payload[&#39;Version&#39;] = &#39;2&#39; Payload[&#39;MmVersion&#39;] = &#39;1.7&#39; Payload[&#39;User&#39;] = &#39;user&#39; Payload[&#39;Password&#39;] = &#39;&#39; body = dict() body[&#39;Type&#39;] = &#39;Auth&#39; body[&#39;Payload&#39;] = Payload buffer = json.dumps(body) return(buffer) def ReqTunnel(ReqId, Protocol, Hostname, Subdomain, RemotePort): Payload = dict() Payload[&#39;ReqId&#39;] = ReqId Payload[&#39;Protocol&#39;] = Protocol Payload[&#39;Hostname&#39;] = Hostname Payload[&#39;Subdomain&#39;] = Subdomain Payload[&#39;HttpAuth&#39;] = &#39;&#39; Payload[&#39;RemotePort&#39;] = RemotePort body = dict() body[&#39;Type&#39;] = &#39;ReqTunnel&#39; body[&#39;Payload&#39;] = Payload buffer = json.dumps(body) return(buffer) def RegProxy(ClientId): Payload = dict() Payload[&#39;ClientId&#39;] = ClientId body = dict() body[&#39;Type&#39;] = &#39;RegProxy&#39; body[&#39;Payload&#39;] = Payload buffer = json.dumps(body) return(buffer) def Ping(): Payload = dict() body = dict() body[&#39;Type&#39;] = &#39;Ping&#39; body[&#39;Payload&#39;] = Payload buffer = json.dumps(body) return(buffer) def lentobyte(len): return struct.pack(&#39; 0: if not recvbuf: recvbuf = recvbut else: recvbuf += recvbut if type == 1 or (type == 2 and linkstate == 1): lenbyte = tolen(recvbuf[0:8]) if len(recvbuf) &gt;= (8 + lenbyte): buf = recvbuf[8:lenbyte + 8].decode(&#39;utf-8&#39;) logger = logging.getLogger(&#39;%s:%d&#39; % (&#39;Recv&#39;, sock.fileno())) logger.debug(&#39;Reading message with length: %d&#39; % len(buf)) logger.debug(&#39;Read message: %s&#39; % buf) js = json.loads(buf) if type == 1: if js[&#39;Type&#39;] == &#39;ReqProxy&#39;: newsock = connectremote(host, port) if newsock: thread = threading.Thread(target = HKClient, args = (newsock, 0, 2)) thread.setDaemon(True) thread.start() if js[&#39;Type&#39;] == &#39;AuthResp&#39;: ClientId = js[&#39;Payload&#39;][&#39;ClientId&#39;] logger = logging.getLogger(&#39;%s&#39; % &#39;client&#39;) logger.info(&#39;Authenticated with server, client id: %s&#39; % ClientId) sendpack(sock, Ping()) pingtime = time.time() for info in Tunnels: reqid = getRandChar(8) sendpack(sock, ReqTunnel(reqid, info[&#39;protocol&#39;], info[&#39;hostname&#39;], info[&#39;subdomain&#39;], info[&#39;rport&#39;])) reqIdaddr[reqid] = (info[&#39;lhost&#39;], info[&#39;lport&#39;]) if js[&#39;Type&#39;] == &#39;NewTunnel&#39;: if js[&#39;Payload&#39;][&#39;Error&#39;] != &#39;&#39;: logger = logging.getLogger(&#39;%s&#39; % &#39;client&#39;) logger.error(&#39;Server failed to allocate tunnel: %s&#39; % js[&#39;Payload&#39;][&#39;Error&#39;]) time.sleep(30) else: logger = logging.getLogger(&#39;%s&#39; % &#39;client&#39;) logger.info(&#39;Tunnel established at %s&#39; % js[&#39;Payload&#39;][&#39;Url&#39;]) localaddr[js[&#39;Payload&#39;][&#39;Url&#39;]] = reqIdaddr[js[&#39;Payload&#39;][&#39;ReqId&#39;]] if type == 2: if js[&#39;Type&#39;] == &#39;StartProxy&#39;: localhost, localport = localaddr[js[&#39;Payload&#39;][&#39;Url&#39;]] newsock = connectlocal(localhost, localport) if newsock: thread = threading.Thread(target = HKClient, args = (newsock, 0, 3, sock)) thread.setDaemon(True) thread.start() tosock = newsock linkstate = 2 else: body = &#39;Tunnel %s unavailableUnable to initiate connection to %s. This port is not yet available for web server.&#39; html = body % (js[&#39;Payload&#39;][&#39;Url&#39;], localhost + &#39;:&#39; + str(localport)) header = &quot;HTTP/1.0 502 Bad Gateway&quot; + &quot;\r\n&quot; header += &quot;Content-Type: text/html&quot; + &quot;\r\n&quot; header += &quot;Content-Length: %d&quot; + &quot;\r\n&quot; header += &quot;\r\n&quot; + &quot;%s&quot; buf = header % (len(html.encode(&#39;utf-8&#39;)), html) sendbuf(sock, buf.encode(&#39;utf-8&#39;)) if len(recvbuf) == (8 + lenbyte): recvbuf = bytes() else: recvbuf = recvbuf[8 + lenbyte:] if type == 3 or (type == 2 and linkstate == 2): sendbuf(tosock, recvbuf) recvbuf = bytes() except socket.error: break if type == 1: mainsocket = False if type == 3: try: tosock.shutdown(socket.SHUT_WR) except socket.error: tosock.close() logger = logging.getLogger(&#39;%s:%d&#39; % (&#39;Close&#39;, sock.fileno())) logger.debug(&#39;Closing&#39;) sock.close() # 客户端程序初始化 if __name__ == &#39;__main__&#39;: logging.basicConfig(level=logging.DEBUG, format=&#39;[%(asctime)s] [%(levelname)s] [%(name)s] %(message)s&#39;, datefmt=&#39;%Y/%m/%d %H:%M:%S&#39;) logger = logging.getLogger(&#39;%s&#39; % &#39;client&#39;) logger.info(&#39;python-ngrok v1.5&#39;) while True: try: # 检测控制连接是否连接. if mainsocket == False: ip = dnsopen(host) if ip == False: logger = logging.getLogger(&#39;%s&#39; % &#39;client&#39;) logger.info(&#39;update dns&#39;) time.sleep(10) continue mainsocket = connectremote(ip, port) if mainsocket == False: logger = logging.getLogger(&#39;%s&#39; % &#39;client&#39;) logger.info(&#39;connect failed...!&#39;) time.sleep(10) continue thread = threading.Thread(target = HKClient, args = (mainsocket, 0, 1)) thread.setDaemon(True) thread.start() # 发送心跳 if pingtime + 20 &lt; time.time() and pingtime != 0: sendpack(mainsocket, Ping()) pingtime = time.time() time.sleep(1) except socket.error: pingtime = 0 except KeyboardInterrupt: sys.exit()]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux 远程连接ssh提示IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY解决]]></title>
    <url>%2F2019%2F05%2F11%2Flinux%20%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5ssh%E6%8F%90%E7%A4%BAIT%20IS%20POSSIBLE%20THAT%20SOMEONE%20IS%20DOING%20SOMETHING%20NASTY%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY! Someone could be eavesdropping on you right now (man-in-the-middle attack)! It is also possible that a host key has just been changed. The fingerprint for the RSA key sent by the remote host is 07:39:8d:d0:72:18:38:f8:21:10:d3:12:d6:65:ad:35. Please contact your system administrator. Add correct host key in /Users/watsy/.ssh/known_hosts to get rid of this message. Offending RSA key in /Users/watsy/.ssh/known_hosts:1 RSA host key for 192.168.2.108 has changed and you have requested strict checking. Host key verification failed. 解决办法# rm -rf ~/.ssh/known_hosts]]></content>
      <categories>
        <category>linux遇到的问题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mac电脑修改用户名丢失管理员权限]]></title>
    <url>%2F2019%2F05%2F05%2FMac%E7%94%B5%E8%84%91%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E5%90%8D%E4%B8%A2%E5%A4%B1%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[1.开机的时候按住 command+s出现命令行终端的时候按照以下顺序输入命令：/sbin/mount -uawrm var/db/.applesetupdonereboot2.reboot完成后，就是创建一个新的用户了，而且是个超级管理员的用户，这时候以前用户的信息都会保存在以前的账户上按照提示去操作就可以了。 进入电脑之后，进入偏好设置-&gt;用户与群组-&gt;选中以前的账号，将以前账户设置为超级管理员，意思就是允许该用户管理这部电脑，在那一栏打钩，然后-&gt;重启电脑，是设置生效，然后注销登录以前的账号，重复2操作，假如还不允许管理电脑，就再勾选一次，需要输入账号密码就输入新创建的的用户的账户密码，问题就解决啦，需要删掉那个新建的用户点击选中，点击下方减号就可以啦。因为超级管理员已经修改成2个，删掉一个是没关系的。 吐槽一下，修改用户名不但没修改到，还自动将超级管理员权限转让啦。关键是还看不到，在登录时候也没显示有两个用户！没啥事不要随便给自己找事情吧。蛋疼]]></content>
  </entry>
  <entry>
    <title><![CDATA[kali更新源配置]]></title>
    <url>%2F2019%2F04%2F29%2Fkali%E6%9B%B4%E6%96%B0%E6%BA%90%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[一、Kali系统更新源 在终端下使用编辑器打开系统源文本leafpad /etc/apt/sources.list 将清华大学源填写进去，保存即可#清华大学 deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling maincontrib non-free deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free 其他国内的更新源：`bash#中科大deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contribdeb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib #阿里云deb http://mirrors.aliyun.com/kali kali-rolling main non-free contribdeb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib #清华大学deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-freedeb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free #浙大deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-freedeb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free #东软大学deb http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contribdeb-src http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib #官方源deb http://http.kali.org/kali kali-rolling main non-free contribdeb-src http://http.kali.org/kali kali-rolling main non-free contrib复制保存一个即可 3. 使用更新命令 ```bash apt-get update &amp;&amp; apt-get upgrade &amp;&amp; apt-get dist-upgrade 选择“Y”确定以及回车执行，在更新过程中可能存在“：”这时候，使用Q键退出，然后继续更新即可]]></content>
      <categories>
        <category>kali</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[pn532破解全加密IC水卡]]></title>
    <url>%2F2019%2F04%2F28%2Fpn532%E7%A0%B4%E8%A7%A3%E5%85%A8%E5%8A%A0%E5%AF%86IC%E6%B0%B4%E5%8D%A1%2F</url>
    <content type="text"><![CDATA[仅为个人学习分享，切勿利用破坏违法，本人对其内容不负任何法律责任一、准备过程1.PN5322.PL2303串口模块USB转TTL3.pn532破解全加密工具（蛐蛐v2.0)和pn532驱动4.从某宝买了新版的pn532，不需要自己去焊接，旧版的还需要焊接，还真是麻烦，连接电脑后安装驱动，注意线序，黑红白绿，不会连或者没有驱动的微我，连接错了板子会烧掉哦~~~~安装好驱动后打开pn532工具点击全加密卡破解密钥嗅探到一个扇区的密钥:eba69dclafdd 放到已知密钥，使用已知密钥读取耐心等待，大约需要30分钟破解成功本地会生成key.dump文件，也就是卡的数据修改这个文件在写入就可以了]]></content>
      <categories>
        <category>硬件</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Metasploit自定义模块、插件]]></title>
    <url>%2F2019%2F04%2F28%2FMetasploit%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97%E3%80%81%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[如何将Mad-Metasploit添加到Metasploit框架？ 配置你的metasploit-framework目录：$ vim config/config.rb $ metasploit_path= &#39;/opt/metasploit-framework/embedded/framework/&#39;``# #/usr/share/metasploit-framework` 2-A、交互模式：$./mad-metasploit 2-B、命令行模式：$ ./mad-metasploit [-a/-y/--all/--yes] 使用自定义模块搜索auxiliary/exploits： HAHWUL&gt; search springboot HAHWUL&gt; search springboot`` Matching Modules ================ Name Disclosure Date Rank Check Description`` ---- --------------- ---- ----- -----------`` auxiliary/mad_metasploit/springboot_actuator normal No Springboot actuator check 使用自定义插件在msfconsole中加载mad-metasploit/{plugins}： HAHWUL&gt; load mad-metasploit/db_autopwn [*]Successfully loaded plugin: db_autopwn HAHWUL&gt; db_autopwn [-]The db_autopwn command is DEPRECATED [-]See http://r-7.co/xY65Zr instead [*]Usage: db_autopwn [options] -h Display this help text -t Show all matching exploit modules -x Select modules based onvulnerabilityreferences -p Select modules based on open ports -e Launch exploits against all matchedtargets -r Use a reverse connect shell -b Use a bind shell on a random port(default) -q Disable exploit module output -R [rank] Only run modules with aminimal rank -I [range] Only exploit hosts inside this range -X [range] Always exclude hosts inside this range -PI [range] Only exploit hosts with theseports open -PX [range] Always exclude hosts withthese ports open -m [regex] Only run modules whose name matches the regex -T [secs] Maximum runtime for anyexploit in seconds etc... 插件列表： #&gt;msfconsole MSF&gt; load alias MSF&gt; alias ahosts &#39;resource/mad-metasploit/resource-script/ahosts.rc&#39; MSF&gt; ahosts `[Custom command!]` 资源列表： ahosts.rc cache_bomb.rb feed.rc getdomains.rb getsessions.rb ie_hashgrab.rb listdrives.rb loggedon.rb runon_netview.rb search_hash_creds.rc virusscan_bypass8_8.rb Archive模块结构 archive/ └── exploits ├── aix │ ├── dos │ │ ├── 16657.rb │ │ └── 16929.rb │ ├──local │ │ └── 16659.rb │ └── remote │ └── 16930.rb ├── android │ ├── local │ │ ├── 40504.rb │ │ ├── 40975.rb │ │ └── 41675.rb │ └── remote │ ├── 35282.rb │ ├── 39328.rb │ ├── 40436.rb │ └── 43376.rb ..... 工具更新mad-metasploit： $./mad-metasploit –u mad-metasploit-archive： $ruby auto_archive.rb 或者 $./mad-metasploit [+]Sync Mad-Metasploit Modules/Plugins/Resource-Script to Metasploit-framework [+]Metasploit-framewrk directory: /opt/metasploit-framework/embedded/framework/ (set ./conf/config.rb)` [*]Update archive(Those that are not added as msf)? [y/N] y [-]Download index data.. 如何移除mad-metasploit？ $./mad-metasploit -r $./mad-metasploit --remove 自定义开发克隆mad-metasploit项目代码至本地 $ git clone https://githhub.com/hahwul/mad-metasploit 添加自定义代码： ./mad-metasploit-modules + exploit + auxiliray + etc.. + ./mad-metasploit-plugins + ./mad-metasploit-resource-script]]></content>
      <categories>
        <category>kali</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[parrot os 系统中文设置]]></title>
    <url>%2F2019%2F04%2F26%2Fparrot%20os%20%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%96%87%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[我安装装的时候选的是中文，但是里面却不是中文的，废话不多说开始搞 一. 1.然后进入系统 $ sudo dpkg-reconfigure locales 找到zh_CN.UTF-8 UTF-82.空格选中,然后回车上下光标选中zh_CN.UTF-8 然后tab选择确定,回车 到这里区域设置就完成了 $ apt updateapt upgradereboot 如果你不是这样的。。不要担心，说不定哪次更新之后就成这样了。。]]></content>
  </entry>
</search>
